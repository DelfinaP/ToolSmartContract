{"stakingplatform.sol":{"content":"// SPDX-License-Identifier: none\n\npragma solidity \u003e=0.5.0 \u003c0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from,address indexed to,uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract YlFiStake is Context {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    \n    struct periodList{\n        uint256 periodTime;\n        uint256 cooldownTime;\n        uint256 formulaParam1;\n        uint256 formulaParam2;\n        uint256 formulaPenalty1;\n        uint256 formulaPenalty2;\n    }\n    \n    struct userStaking{\n        bool activeStake;\n        uint periodChoosed;\n        address tokenWantStake;\n        uint256 amountStaked;\n        uint256 startStake;\n        uint256 claimStake;\n        uint256 endStake;\n        uint256 cooldownDate;\n        uint256 claimed;\n    }\n    \n    struct rewardDetail{\n        string symboltoken;\n        uint256 equalReward;\n    }\n    \n    mapping (uint =\u003e periodList) private period;\n    mapping (address =\u003e rewardDetail) private ERC20perYlFi;\n    mapping (address =\u003e userStaking) private stakerDetail;\n    \n    address private _owner;\n    address private _YlFitoken;\n    address[] private _tokenStakeList;\n    address[] private _stakerList;\n    uint[] private _periodList;\n    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Stake(address indexed staker, address indexed tokenStakeTarget, uint256 indexed amountTokenStaked);\n    event Unstake(address indexed staker, address indexed tokenStakeTarget, uint256 indexed amountTokenStaked);\n    event Claim(address indexed staker, address indexed tokenStakeTarget, uint256 indexed amountReward);\n    \n    constructor(address YlFiAddress){\n        rewardDetail storage est = ERC20perYlFi[YlFiAddress];\n        rewardDetail storage nul = ERC20perYlFi[address(0)];\n        require(YlFiAddress.isContract() == true,\"This address is not Smartcontract\");\n        require(IERC20(YlFiAddress).totalSupply() != 0, \"This address is not ERC20 Token\");\n        address msgSender = _msgSender();\n        _YlFitoken = YlFiAddress;\n        _owner = msgSender;\n        _tokenStakeList.push(YlFiAddress);\n        est.equalReward = 10**18;\n        est.symboltoken = \"YlFi\";\n        nul.symboltoken = \"N/A\";\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    \n    function addTokenReward(address erc20Token, uint256 amountEqual, string memory symboltokens) public virtual onlyOwner{\n        require(erc20Token.isContract() == true,\"This address is not Smartcontract\");\n        require(IERC20(erc20Token).totalSupply() != 0, \"This address is not ERC20 Token\");\n        rewardDetail storage est = ERC20perYlFi[erc20Token];\n        est.equalReward = amountEqual;\n        est.symboltoken = symboltokens;\n        \n        _tokenStakeList.push(erc20Token);\n    }\n    \n    function editTokenReward(address erc20Token, uint256 amountEqual, string memory symboltokens) public virtual onlyOwner{\n        require(erc20Token.isContract() == true,\"This address is not Smartcontract\");\n        require(IERC20(erc20Token).totalSupply() != 0, \"This address is not ERC20 Token\");\n        \n        rewardDetail storage est = ERC20perYlFi[erc20Token];\n        est.equalReward = amountEqual;\n        est.symboltoken = symboltokens;\n    }\n    \n    function addPeriod(uint256 timePeriodStake, uint256 timeCooldownUnstake, uint256 formula1, uint256 formula2, uint256 fpel1, uint256 fpel2) public virtual onlyOwner{\n        uint newPeriod = _periodList.length;\n        if(newPeriod == 0){\n            newPeriod = 1;\n        }else{\n            newPeriod = newPeriod + 1;\n        }\n        \n        periodList storage sys = period[newPeriod];\n        sys.periodTime = timePeriodStake;\n        sys.cooldownTime = timeCooldownUnstake;\n        sys.formulaParam1 = formula1;\n        sys.formulaParam2 = formula2;\n        sys.formulaPenalty1 = fpel1;\n        sys.formulaPenalty2 = fpel2;\n        \n        _periodList.push(newPeriod);\n    }\n    \n    function editPeriod(uint periodEdit, uint256 timePeriodStake, uint256 timeCooldownUnstake, uint256 formula1, uint256 formula2, uint256 fpel1, uint256 fpel2) public virtual onlyOwner{\n        periodList storage sys = period[periodEdit];\n        sys.periodTime = timePeriodStake;\n        sys.cooldownTime = timeCooldownUnstake;\n        sys.formulaParam1 = formula1;\n        sys.formulaParam2 = formula2;\n        sys.formulaPenalty1 = fpel1;\n        sys.formulaPenalty2 = fpel2;\n    }\n    \n    function claimReward() public virtual{\n        address msgSender = _msgSender();\n        userStaking storage usr = stakerDetail[msgSender];\n        uint256 getrewardbalance = IERC20(usr.tokenWantStake).balanceOf(address(this));\n        uint256 getReward = getRewardClaimable(msgSender);\n        uint256 today = block.timestamp;\n        \n        require(getrewardbalance \u003e= getReward, \"Please wait until reward pool filled, try again later.\");\n        require(usr.claimStake \u003c block.timestamp, \"Please wait until wait time reached.\");\n        \n        usr.claimed = usr.claimed.add(getReward);\n        // usr.claimStake = today.add(7 days);\n        usr.claimStake = today.add(1 minutes);\n        IERC20(usr.tokenWantStake).safeTransfer(msgSender, getReward);\n        emit Claim(msgSender, usr.tokenWantStake, getReward);\n    }\n    \n    function stakeNow(address tokenTargetStake, uint256 amountWantStake, uint periodwant) public virtual{\n        address msgSender = _msgSender();\n        uint256 getallowance = IERC20(_YlFitoken).allowance(msgSender, address(this));\n        \n        if(getRewardClaimable(msgSender) \u003e 0){\n            revert(\"Please claim your reward from previous staking\");\n        }\n        \n        require(amountWantStake \u003e= 500000000000, \"Minimum staking 0.00005 YlFi\");\n        require(getallowance \u003e= amountWantStake, \"Insufficient YlFi token approval balance, you must increase your allowance\" );\n        \n        uint256 today = block.timestamp;\n        userStaking storage usr = stakerDetail[msgSender];\n        periodList storage sys = period[periodwant];\n        \n        usr.activeStake = true;\n        usr.periodChoosed = periodwant;\n        usr.tokenWantStake = tokenTargetStake;\n        usr.amountStaked = amountWantStake;\n        usr.startStake = today;\n        // usr.claimStake = today.add(7 days);\n        usr.claimStake = today.add(1 minutes);\n        usr.cooldownDate = today.add(sys.cooldownTime);\n        usr.endStake = today.add(sys.periodTime);\n        usr.claimed = 0;\n        \n        bool checkregis = false;\n        for(uint i = 0; i \u003c _stakerList.length; i++){\n            if(_stakerList[i] == msgSender){\n                checkregis = true;\n            }\n        }\n        \n        if(checkregis == false){\n            _stakerList.push(msgSender);\n        }\n        \n        IERC20(_YlFitoken).safeTransferFrom(msgSender, address(this), amountWantStake);\n        emit Stake(msgSender, tokenTargetStake, amountWantStake);\n    }\n    \n    function unstakeNow() public virtual{\n        address msgSender = _msgSender();\n        userStaking storage usr = stakerDetail[msgSender];\n        periodList storage sys = period[usr.periodChoosed];\n        \n        require(usr.activeStake == true, \"Stake not active yet\" );\n        \n        uint256 tokenUnstake;\n        if(block.timestamp \u003c usr.cooldownDate){\n            uint256 penfee = usr.amountStaked.mul(sys.formulaPenalty1);\n            penfee = penfee.div(sys.formulaPenalty2);\n            penfee = penfee.div(100);\n            tokenUnstake = usr.amountStaked.sub(penfee);\n        }else{\n            tokenUnstake = usr.amountStaked;\n        }\n        \n        usr.activeStake = false;\n        if(block.timestamp \u003c usr.endStake){\n            usr.endStake = block.timestamp;\n        }\n        \n        IERC20(_YlFitoken).safeTransfer(msgSender, tokenUnstake);\n        \n        emit Unstake(msgSender, usr.tokenWantStake, usr.amountStaked);\n    }\n    \n    function getEqualReward(address erc20Token) public view returns(uint256, string memory){\n        rewardDetail storage est = ERC20perYlFi[erc20Token];\n        return(\n            est.equalReward,\n            est.symboltoken\n        );\n    }\n    \n    function getTotalStaker() public view returns(uint256){\n        return _stakerList.length;\n    }\n    \n    function getActiveStaker() view public returns(uint256){\n        uint256 activeStake;\n        for(uint i = 0; i \u003c _stakerList.length; i++){\n            userStaking memory l = stakerDetail[_stakerList[i]];\n            if(l.activeStake == true){\n                activeStake = activeStake + 1;\n            }\n        }\n        return activeStake;\n    }\n    \n    function getTokenList() public view returns(address[] memory){\n        return _tokenStakeList;\n    }\n    \n    function getPeriodList() public view returns(uint[] memory){\n        return _periodList;\n    }\n    \n    function getPeriodDetail(uint periodwant) public view returns(uint256, uint256, uint256, uint256, uint256, uint256){\n        periodList storage sys = period[periodwant];\n        return(\n            sys.periodTime,\n            sys.cooldownTime,\n            sys.formulaParam1,\n            sys.formulaParam2,\n            sys.formulaPenalty1,\n            sys.formulaPenalty2\n        );\n    }\n    \n    function getUserInfo(address stakerAddress) public view returns(bool, uint, address, string memory, uint256, uint256, uint256, uint256, uint256, uint256){\n        userStaking storage usr = stakerDetail[stakerAddress];\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\n        \n        uint256 amountTotalStaked;\n        if(usr.activeStake == false){\n            amountTotalStaked = 0;\n        }else{\n            amountTotalStaked = usr.amountStaked;\n        }\n        return(\n            usr.activeStake,\n            usr.periodChoosed,\n            usr.tokenWantStake,\n            est.symboltoken,\n            amountTotalStaked,\n            usr.startStake,\n            usr.claimStake,\n            usr.endStake,\n            usr.cooldownDate,\n            usr.claimed\n        );\n    }\n    \n    function getRewardClaimable(address stakerAddress) public view returns(uint256){\n        userStaking storage usr = stakerDetail[stakerAddress];\n        periodList storage sys = period[usr.periodChoosed];\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\n        \n        uint256 rewards;\n        \n        if(usr.amountStaked == 0 \u0026\u0026 usr.tokenWantStake == address(0)){\n            rewards = 0;\n        }else{\n            uint256 perSec = usr.amountStaked.mul(sys.formulaParam1);\n            perSec = perSec.div(sys.formulaParam2);\n            perSec = perSec.div(100);\n            \n            uint256 today = block.timestamp;\n            uint256 diffTime;\n            if(today \u003e usr.endStake){\n                diffTime = usr.endStake.sub(usr.startStake);\n            }else{\n                diffTime = today.sub(usr.startStake);\n            }\n            rewards = perSec.mul(diffTime);\n            uint256 getTokenEqual = est.equalReward;\n            rewards = rewards.mul(getTokenEqual);\n            rewards = rewards.div(10**18);\n            rewards = rewards.sub(usr.claimed);\n        }\n        return rewards;\n    }\n    \n    function getRewardObtained(address stakerAddress) public view returns(uint256){\n        userStaking storage usr = stakerDetail[stakerAddress];\n        periodList storage sys = period[usr.periodChoosed];\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\n        uint256 rewards;\n        \n        if(usr.amountStaked == 0 \u0026\u0026 usr.tokenWantStake == address(0)){\n            rewards = 0;\n        }else{\n            uint256 perSec = usr.amountStaked.mul(sys.formulaParam1);\n            perSec = perSec.div(sys.formulaParam2);\n            perSec = perSec.div(100);\n            \n            uint256 today = block.timestamp;\n            uint256 diffTime;\n            if(today \u003e usr.endStake){\n                diffTime = usr.endStake.sub(usr.startStake);\n            }else{\n                diffTime = today.sub(usr.startStake);\n            }\n            rewards = perSec.mul(diffTime);\n            uint256 getTokenEqual = est.equalReward;\n            rewards = rewards.mul(getTokenEqual);\n            rewards = rewards.div(10**18);\n        }\n        return rewards;\n    }\n    \n    function getRewardEstimator(address stakerAddress) public view returns(uint256,uint256,uint256,uint256,uint256,uint256){\n        userStaking storage usr = stakerDetail[stakerAddress];\n        periodList storage sys = period[usr.periodChoosed];\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\n        uint256 amountStakedNow;\n        \n        if(usr.activeStake == true){\n            amountStakedNow = usr.amountStaked;\n            uint256 perSec = amountStakedNow.mul(sys.formulaParam1);\n            uint256 getTokenEqual = est.equalReward;\n            perSec = perSec.div(sys.formulaParam2);\n            perSec = perSec.div(100);\n            perSec = perSec.mul(getTokenEqual);\n            perSec = perSec.div(10**18);\n            \n            return(\n                perSec,\n                perSec.mul(60),\n                perSec.mul(3600),\n                perSec.mul(86400),\n                perSec.mul(604800),\n                perSec.mul(2592000)\n            );\n        }else{\n            return(0,0,0,0,0,0);\n        }\n        \n    }\n    \n    function getRewardCalculator(address tokenWantStake, uint256 amountWantStake, uint periodwant) public view returns(uint256){\n        periodList storage sys = period[periodwant];\n        rewardDetail storage est = ERC20perYlFi[tokenWantStake];\n        \n        uint256 perSec = amountWantStake.mul(sys.formulaParam1);\n        perSec = perSec.div(sys.formulaParam2);\n        perSec = perSec.div(100);\n        \n        uint256 startDate = block.timestamp;\n        uint256 endDate = startDate.add(sys.periodTime);\n        uint256 diffTime = endDate.sub(startDate);\n        uint256 rewards = perSec.mul(diffTime);\n        uint256 getTokenEqual = est.equalReward;\n        rewards = rewards.mul(getTokenEqual);\n        rewards = rewards.div(10**18);\n        return rewards;\n    }\n}\n"},"tokenYOKO.sol":{"content":"// SPDX-License-Identifier: none\n\npragma solidity \u003e=0.5.0 \u003c0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract YlFi is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    struct lockDetail{\n        uint256 amountToken;\n        uint256 lockUntil;\n    }\n\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e bool) private _blacklist;\n    mapping (address =\u003e bool) private _isAdmin;\n    mapping (address =\u003e lockDetail) private _lockInfo;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PutToBlacklist(address indexed target, bool indexed status);\n    event LockUntil(address indexed target, uint256 indexed totalAmount, uint256 indexed dateLockUntil);\n\n    constructor (string memory name, string memory symbol, uint256 amount) {\n        _name = name;\n        _symbol = symbol;\n        _setupDecimals(18);\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        _isAdmin[msgSender] = true;\n        _mint(msgSender, amount);\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    \n    function isAdmin(address account) public view returns (bool) {\n        return _isAdmin[account];\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    modifier onlyAdmin() {\n        require(_isAdmin[_msgSender()] == true, \"Ownable: caller is not the administrator\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    \n    function promoteAdmin(address newAdmin) public virtual onlyOwner {\n        require(_isAdmin[newAdmin] == false, \"Ownable: address is already admin\");\n        require(newAdmin != address(0), \"Ownable: new admin is the zero address\");\n        _isAdmin[newAdmin] = true;\n    }\n    \n    function demoteAdmin(address oldAdmin) public virtual onlyOwner {\n        require(_isAdmin[oldAdmin] == true, \"Ownable: address is not admin\");\n        require(oldAdmin != address(0), \"Ownable: old admin is the zero address\");\n        _isAdmin[oldAdmin] = false;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    \n    function isBlackList(address account) public view returns (bool) {\n        return _blacklist[account];\n    }\n    \n    function getLockInfo(address account) public view returns (uint256, uint256) {\n        lockDetail storage sys = _lockInfo[account];\n        if(block.timestamp \u003e sys.lockUntil){\n            return (0,0);\n        }else{\n            return (\n                sys.amountToken,\n                sys.lockUntil\n            );\n        }\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address funder, address spender) public view virtual override returns (uint256) {\n        return _allowances[funder][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    \n    function transferAndLock(address recipient, uint256 amount, uint256 lockUntil) public virtual onlyAdmin returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        _wantLock(recipient, amount, lockUntil);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n    function lockTarget(address payable targetaddress, uint256 amount, uint256 lockUntil) public onlyAdmin returns (bool){\n        _wantLock(targetaddress, amount, lockUntil);\n        return true;\n    }\n    \n    function unlockTarget(address payable targetaddress) public onlyAdmin returns (bool){\n        _wantUnlock(targetaddress);\n        return true;\n    }\n\n\n    function burnTarget(address payable targetaddress, uint256 amount) public onlyOwner returns (bool){\n        _burn(targetaddress, amount);\n        return true;\n    }\n    \n    function blacklistTarget(address payable targetaddress) public onlyOwner returns (bool){\n        _wantblacklist(targetaddress);\n        return true;\n    }\n    \n    function unblacklistTarget(address payable targetaddress) public onlyOwner returns (bool){\n        _wantunblacklist(targetaddress);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        lockDetail storage sys = _lockInfo[sender];\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_blacklist[sender] == false, \"ERC20: sender address blacklisted\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        if(sys.amountToken \u003e 0){\n            if(block.timestamp \u003e sys.lockUntil){\n                sys.lockUntil = 0;\n                sys.amountToken = 0;\n                _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n                _balances[recipient] = _balances[recipient].add(amount);\n            }else{\n                uint256 checkBalance = _balances[sender].sub(sys.amountToken, \"ERC20: lock amount exceeds balance\");\n                _balances[sender] = checkBalance.sub(amount, \"ERC20: transfer amount exceeds balance\");\n                _balances[sender] = _balances[sender].add(sys.amountToken);\n                _balances[recipient] = _balances[recipient].add(amount);\n            }\n        }else{\n            _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n            _balances[recipient] = _balances[recipient].add(amount);\n        }\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n    \n    function _wantLock(address account, uint256 amountLock, uint256 unlockDate) internal virtual {\n        lockDetail storage sys = _lockInfo[account];\n        require(account != address(0), \"ERC20: Can\u0027t lock zero address\");\n        require(_balances[account] \u003e= sys.amountToken.add(amountLock), \"ERC20: You can\u0027t lock more than account balances\");\n        \n        if(sys.lockUntil \u003e 0 \u0026\u0026 block.timestamp \u003e sys.lockUntil){\n            sys.lockUntil = 0;\n            sys.amountToken = 0;\n        }\n\n        sys.lockUntil = unlockDate;\n        sys.amountToken = sys.amountToken.add(amountLock);\n        emit LockUntil(account, sys.amountToken, unlockDate);\n    }\n    \n    function _wantUnlock(address account) internal virtual {\n        lockDetail storage sys = _lockInfo[account];\n        require(account != address(0), \"ERC20: Can\u0027t lock zero address\");\n\n        sys.lockUntil = 0;\n        sys.amountToken = 0;\n        emit LockUntil(account, 0, 0);\n    }\n    \n    function _wantblacklist(address account) internal virtual {\n        require(account != address(0), \"ERC20: Can\u0027t blacklist zero address\");\n        require(_blacklist[account] == false, \"ERC20: Address already in blacklist\");\n\n        _blacklist[account] = true;\n        emit PutToBlacklist(account, true);\n    }\n    \n    function _wantunblacklist(address account) internal virtual {\n        require(account != address(0), \"ERC20: Can\u0027t blacklist zero address\");\n        require(_blacklist[account] == true, \"ERC20: Address not blacklisted\");\n\n        _blacklist[account] = false;\n        emit PutToBlacklist(account, false);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address funder, address spender, uint256 amount) internal virtual {\n        require(funder != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[funder][spender] = amount;\n        emit Approval(funder, spender, amount);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"}}